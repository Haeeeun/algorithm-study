```javascript
function solution(m, musicinfos) {
    let answer = []
    
    // # => 소문자 치환
    m = m.replace(/A#/g, 'a')
    m = m.replace(/C#/g, 'c')
    m = m.replace(/D#/g, 'd')
    m = m.replace(/F#/g, 'f')
    m = m.replace(/G#/g, 'g')
    
    // m의 길이
    const lenM = m.length
    
    // 각각의 array로 분리
    let infos = musicinfos.map(v => v.split(","))
    
    // infos의 음계 중 # => 소문자 치환
    infos.forEach(v => {
        v[3] = v[3].replace(/A#/g, 'a')
        v[3] = v[3].replace(/C#/g, 'c')
        v[3] = v[3].replace(/D#/g, 'd')
        v[3] = v[3].replace(/F#/g, 'f')
        v[3] = v[3].replace(/G#/g, 'g')
    })
    
    // 변수 할당
    for (let [startT, endT, title, scale] of infos) {
        
        // 시간 계산
        startT = startT.split(":")
        endT = endT.split(":")
        // parseInt를 안써서 27, 30번 테스트케이스에서 계속 실패했다.
        // string을 split하면 string인게 당연한거고,
        // javascript에서 string을 숫자처럼 계산하는건 자주일어나는 실수인데.. 너무 늦게 깨달았다..
        startT = parseInt(startT[0]) * 60 + parseInt(startT[1])
        endT = parseInt(endT[0]) * 60 + parseInt(endT[1])
        // 00:00일 경우를 고려해서 절댓값 함수를 넣었는데 나중에 보니 필요 없었다.
        // const time = Math.abs(endT - startT)
        const time = endT - startT
        
        // 음계 시간
        const len = scale.length
        
        // 음계 쌓기
        let str = ""
        for (let i=0; i<time; i++) {
            str += scale[i % len]
            
            // m과 비교하는 것이므로 m보다 길이가 길어지면 맨 앞 글자 삭제
            // 이렇게 풀고나서 시간에 영향이 있나 없나 의아해서 글자를 자르지 않고
            // m === str 대신 str.includes(m)을 해봤더니 2배정도 느려졌다.
            if (str.length > lenM) str = str.substr(1)
            // m과 같은게 나오면 종료
            if (m === str) {
                answer.push([title, time])
                break
            }
        }
    }
    
    // "`(None)`"로 하면 안풀린다..
    if (answer.length === 0) return "(None)"
    else {
        // 정렬
        // 중간에 27, 30번이 해결이 안될 때 정렬에서 문제가 있나 해서 아래처럼 수정을 했으나,
        const max = Math.max.apply(null, answer.map(v => v[1]))
        return answer.filter(v => v[1] === max)[0][0]
        // 합격하고 확인해보니 그냥 sort처리 해도 괜찮았음.
        // return answer.sort((a, b) => b[1] - a[1])[0][0]
        // 속도에선 별로 차이 안남.
    }
}
```